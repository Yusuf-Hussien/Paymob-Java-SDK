package com.paymob.sdk.performance;

import com.github.tomakehurst.wiremock.junit5.WireMockTest;
import com.github.tomakehurst.wiremock.junit5.WireMockTestExtension;
import com.paymob.sdk.core.PaymobClient;
import com.paymob.sdk.core.PaymobConfig;
import com.paymob.sdk.core.PaymobRegion;
import com.paymob.sdk.services.intention.IntentionRequest;
import com.paymob.sdk.services.intention.IntentionResponse;
import com.paymob.sdk.models.common.BillingData;
import com.paymob.sdk.models.common.Item;
import com.paymob.sdk.models.enums.Currency;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;

import static com.github.tomakehurst.wiremock.client.WireMock.*;
import static org.junit.jupiter.api.Assertions.*;

import java.util.Arrays;
import java.util.List;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

@ExtendWith(WireMockTestExtension.class)
@WireMockTest(httpPort = 8080)
class LoadTest {

    private PaymobClient client;
    private PaymobConfig config;

    @BeforeEach
    void setUp() {
        config = PaymobConfig.builder()
                .secretKey("sk_test_123456789")
                .apiKey("ak_test_123456789")
                .publicKey("pk_test_123456789")
                .region(PaymobRegion.EGYPT)
                .build();

        client = PaymobClient.builder()
                .config(config)
                .build();

        // Mock successful response for load testing
        stubFor(post(urlEqualTo("/v1/intention/"))
                .willReturn(aResponse()
                        .withStatus(201)
                        .withHeader("Content-Type", "application/json")
                        .withBody("""
                                {
                                    "client_secret": "cs_test_123456789",
                                    "redirection_url": "https://webhook.site/test",
                                    "special_reference": "order-123",
                                    "amount": 10000,
                                    "currency": "EGP",
                                    "payment_keys": [
                                        {
                                            "integration": 123456,
                                            "key": "payment_key_123",
                                            "gateway_type": "MIGS",
                                            "order_id": 987654321,
                                            "save_card": true
                                        }
                                    ]
                                }
                                """)));
    }

    @Test
    void testConcurrentRequests() throws InterruptedException {
        int numberOfThreads = 10;
        int requestsPerThread = 5;
        ExecutorService executor = Executors.newFixedThreadPool(numberOfThreads);
        CountDownLatch latch = new CountDownLatch(numberOfThreads);
        
        AtomicInteger successCount = new AtomicInteger(0);
        AtomicInteger errorCount = new AtomicInteger(0);
        AtomicLong totalResponseTime = new AtomicLong(0);

        for (int i = 0; i < numberOfThreads; i++) {
            final int threadId = i;
            executor.submit(() -> {
                try {
                    for (int j = 0; j < requestsPerThread; j++) {
                        long startTime = System.currentTimeMillis();
                        
                        try {
                            IntentionResponse response = createTestIntention(threadId, j);
                            assertNotNull(response);
                            successCount.incrementAndGet();
                        } catch (Exception e) {
                            errorCount.incrementAndGet();
                        }
                        
                        long responseTime = System.currentTimeMillis() - startTime;
                        totalResponseTime.addAndGet(responseTime);
                    }
                } finally {
                    latch.countDown();
                }
            });
        }

        // Wait for all threads to complete
        assertTrue(latch.await(30, TimeUnit.SECONDS), "Load test should complete within 30 seconds");
        
        executor.shutdown();

        // Verify results
        int totalRequests = numberOfThreads * requestsPerThread;
        assertEquals(totalRequests, successCount.get() + errorCount.get());
        assertTrue(successCount.get() > 0, "Should have successful requests");
        assertTrue(errorCount.get() == 0, "Should have no errors: " + errorCount.get());
        
        double averageResponseTime = (double) totalResponseTime.get() / totalRequests;
        System.out.println("Load Test Results:");
        System.out.println("Total Requests: " + totalRequests);
        System.out.println("Successful Requests: " + successCount.get());
        System.out.println("Failed Requests: " + errorCount.get());
        System.out.println("Average Response Time: " + averageResponseTime + "ms");
        
        // Performance assertions
        assertTrue(averageResponseTime < 1000, "Average response time should be less than 1 second");
    }

    @Test
    void testSustainedLoad() throws InterruptedException {
        int durationSeconds = 10;
        int targetRPS = 5; // Requests per second
        ExecutorService executor = Executors.newFixedThreadPool(targetRPS * 2);
        
        AtomicInteger requestCount = new AtomicInteger(0);
        AtomicInteger successCount = new AtomicInteger(0);
        AtomicInteger errorCount = new AtomicInteger(0);
        AtomicLong totalResponseTime = new AtomicLong(0);
        
        long startTime = System.currentTimeMillis();
        long endTime = startTime + (durationSeconds * 1000);

        while (System.currentTimeMillis() < endTime) {
            executor.submit(() -> {
                try {
                    long requestStart = System.currentTimeMillis();
                    
                    try {
                        IntentionResponse response = createTestIntention(0, requestCount.get());
                        assertNotNull(response);
                        successCount.incrementAndGet();
                    } catch (Exception e) {
                        errorCount.incrementAndGet();
                    }
                    
                    long responseTime = System.currentTimeMillis() - requestStart;
                    totalResponseTime.addAndGet(responseTime);
                    requestCount.incrementAndGet();
                    
                } catch (Exception e) {
                    errorCount.incrementAndGet();
                }
            });
            
            // Rate limiting: wait to achieve target RPS
            Thread.sleep(1000 / targetRPS);
        }

        executor.shutdown();
        executor.awaitTermination(5, TimeUnit.SECONDS);

        // Calculate metrics
        long actualDuration = System.currentTimeMillis() - startTime;
        double actualRPS = (double) requestCount.get() / (actualDuration / 1000.0);
        double averageResponseTime = requestCount.get() > 0 ? 
            (double) totalResponseTime.get() / requestCount.get() : 0;
        double successRate = requestCount.get() > 0 ? 
            (double) successCount.get() / requestCount.get() * 100 : 0;

        System.out.println("Sustained Load Test Results:");
        System.out.println("Duration: " + actualDuration + "ms");
        System.out.println("Total Requests: " + requestCount.get());
        System.out.println("Target RPS: " + targetRPS);
        System.out.println("Actual RPS: " + String.format("%.2f", actualRPS));
        System.out.println("Success Rate: " + String.format("%.2f", successRate) + "%");
        System.out.println("Average Response Time: " + String.format("%.2f", averageResponseTime) + "ms");
        System.out.println("Successful Requests: " + successCount.get());
        System.out.println("Failed Requests: " + errorCount.get());

        // Performance assertions
        assertTrue(actualRPS >= targetRPS * 0.8, "Should achieve at least 80% of target RPS");
        assertTrue(successRate >= 95.0, "Success rate should be at least 95%");
        assertTrue(averageResponseTime < 500, "Average response time should be less than 500ms");
    }

    @Test
    void testMemoryUsageUnderLoad() throws InterruptedException {
        Runtime runtime = Runtime.getRuntime();
        
        // Force garbage collection and measure initial memory
        System.gc();
        Thread.sleep(100);
        long initialMemory = runtime.totalMemory() - runtime.freeMemory();
        
        int numberOfRequests = 100;
        ExecutorService executor = Executors.newFixedThreadPool(20);
        CountDownLatch latch = new CountDownLatch(numberOfRequests);
        
        for (int i = 0; i < numberOfRequests; i++) {
            final int requestId = i;
            executor.submit(() -> {
                try {
                    createTestIntention(requestId, 0);
                } catch (Exception e) {
                    // Ignore for memory test
                } finally {
                    latch.countDown();
                }
            });
        }
        
        assertTrue(latch.await(30, TimeUnit.SECONDS));
        executor.shutdown();
        
        // Measure memory after load
        System.gc();
        Thread.sleep(100);
        long finalMemory = runtime.totalMemory() - runtime.freeMemory();
        
        long memoryIncrease = finalMemory - initialMemory;
        double memoryIncreasePerRequest = (double) memoryIncrease / numberOfRequests;
        
        System.out.println("Memory Usage Test Results:");
        System.out.println("Initial Memory: " + (initialMemory / 1024 / 1024) + "MB");
        System.out.println("Final Memory: " + (finalMemory / 1024 / 1024) + "MB");
        System.out.println("Memory Increase: " + (memoryIncrease / 1024 / 1024) + "MB");
        System.out.println("Memory per Request: " + String.format("%.2f", memoryIncreasePerRequest) + " bytes");
        
        // Memory assertions
        assertTrue(memoryIncreasePerRequest < 10000, "Memory increase per request should be less than 10KB");
    }

    private IntentionResponse createTestIntention(int threadId, int requestId) {
        BillingData billingData = new BillingData("Test User " + threadId, "User", 
                "test" + threadId + requestId + "@example.com", "+20123456789" + threadId);
        Item item = new Item("Test Product " + requestId, 10000, "Test Description", 1);
        
        IntentionRequest request = new IntentionRequest(10000, Currency.EGP, Arrays.asList(item), billingData);
        request.setPaymentMethods(Arrays.asList(123456));
        request.setSpecialReference("order-" + threadId + "-" + requestId);
        
        return client.intentions().createIntention(request);
    }
}
